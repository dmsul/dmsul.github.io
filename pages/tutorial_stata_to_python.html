<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Stata to Python Equivalents - Daniel M. Sullivan</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://www.danielmsullivan.com/pages/tutorial_stata_to_python.html">

        <meta name="author" content="Daniel M. Sullivan" />
        <meta name="description" content="Contents 1   Intro/Note on Notation 2   Note on composability 3   Input/Output 4   Sample Selection 5   Data Info and Summary Statistics 6   Variable Manipulation 7   Bysort 8   Panel Data 9   Merging and Joining 10   Reshape 11   Econometrics 12   Plotting 13   Other differences td { padding: 7px; } tr:nth-child(even){background-color: #eeeeee;} Special thanks to John Coglianese for feedback and for supplying the list of &#34;vital …" />

    <meta property="og:site_name" content="Daniel M. Sullivan" />
    <meta property="og:type" content="article"/>
    <meta property="og:title" content="Stata to Python Equivalents"/>
    <meta property="og:url" content="http://www.danielmsullivan.com/pages/tutorial_stata_to_python.html"/>
    <meta property="og:description" content="Contents 1   Intro/Note on Notation 2   Note on composability 3   Input/Output 4   Sample Selection 5   Data Info and Summary Statistics 6   Variable Manipulation 7   Bysort 8   Panel Data 9   Merging and Joining 10   Reshape 11   Econometrics 12   Plotting 13   Other differences td { padding: 7px; } tr:nth-child(even){background-color: #eeeeee;} Special thanks to John Coglianese for feedback and for supplying the list of &#34;vital …" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://www.danielmsullivan.com/theme/css/bootstrap.flatly.min.css" type="text/css"/>
    <link href="http://www.danielmsullivan.com/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://www.danielmsullivan.com/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://www.danielmsullivan.com/theme/css/style.css" type="text/css"/>





</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://www.danielmsullivan.com/" class="navbar-brand">
Daniel M. Sullivan            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="/pdf/Sullivan_CV.pdf">CV</a></li>
                    <li><a href="/pages/research.html">Research</a></li>
                    <li><a href="/pages/code.html">Code</a></li>
                    <li><a href="/pages/tutorials.html">Tutorials</a></li>
                    <li><a href="/pages/contact.html">Contact</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<!-- Banner -->
<!-- End Banner -->

<!-- Content Container -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content" class="body">
        <h1 class="entry-title">Stata to Python Equivalents</h1>
        
        <div class="entry-content">
            <div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#intro-note-on-notation" id="id1">1&nbsp;&nbsp;&nbsp;Intro/Note on Notation</a></li>
<li><a class="reference internal" href="#note-on-composability" id="id2">2&nbsp;&nbsp;&nbsp;Note on composability</a></li>
<li><a class="reference internal" href="#input-output" id="id3">3&nbsp;&nbsp;&nbsp;Input/Output</a></li>
<li><a class="reference internal" href="#sample-selection" id="id4">4&nbsp;&nbsp;&nbsp;Sample Selection</a></li>
<li><a class="reference internal" href="#data-info-and-summary-statistics" id="id5">5&nbsp;&nbsp;&nbsp;Data Info and Summary Statistics</a></li>
<li><a class="reference internal" href="#variable-manipulation" id="id6">6&nbsp;&nbsp;&nbsp;Variable Manipulation</a></li>
<li><a class="reference internal" href="#bysort" id="id7">7&nbsp;&nbsp;&nbsp;Bysort</a></li>
<li><a class="reference internal" href="#panel-data" id="id8">8&nbsp;&nbsp;&nbsp;Panel Data</a></li>
<li><a class="reference internal" href="#merging-and-joining" id="id9">9&nbsp;&nbsp;&nbsp;Merging and Joining</a></li>
<li><a class="reference internal" href="#reshape" id="id10">10&nbsp;&nbsp;&nbsp;Reshape</a></li>
<li><a class="reference internal" href="#econometrics" id="id11">11&nbsp;&nbsp;&nbsp;Econometrics</a></li>
<li><a class="reference internal" href="#plotting" id="id12">12&nbsp;&nbsp;&nbsp;Plotting</a></li>
<li><a class="reference internal" href="#other-differences" id="id13">13&nbsp;&nbsp;&nbsp;Other differences</a></li>
</ul>
</div>
<style>     td {       padding: 7px;     }     tr:nth-child(even){background-color: #eeeeee;} </style><p>Special thanks to John Coglianese for feedback and for supplying the list of
&quot;vital&quot; Stata commands. Feedback and requests for additions to the list are
always welcome!</p>
<p>The official Pandas documentation includes a <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/comparison_with_stata.html">&quot;Comparison with Stata&quot;</a>
page which is another great resource.</p>
<div class="section" id="intro-note-on-notation">
<h2><a class="toc-backref" href="#id1">1&nbsp;&nbsp;&nbsp;Intro/Note on Notation</a></h2>
<p>Coding in Python is a little different than coding in Stata.</p>
<p>In Stata, you have one dataset in memory. The dataset is a matrix where each
column is a &quot;variable&quot; with a unique name and each row has a number (the
special variable <code>_n</code>). Everything in Stata is built around this
paradigm.</p>
<p>Python is a general purpose programming language where a &quot;variable&quot; is not a
column of data. Variables can be anything, a single number, a matrix, a list, a
string, etc. The Pandas package implements a kind of variable called a
DataFrame that acts a lot like the single dataset in Stata. It is a matrix
where each column and each row has a name. The key distinction in Python is
that a DataFrame is itself a variable and you can work with any number of
DataFrames at one time. You can think of each column in a DataFrame as a
variable just like in Stata, except that when you reference a column, you also
have to specify the DataFrame.</p>
<p>The Stata-to-Python translations below are written assuming that you have a
single DataFrame called <code>df</code>. Placeholders like <code>&lt;varname&gt;</code> and
<code>&lt;dtafile&gt;</code> show where user-specified values go in each language. Note
that in many cases, <code>&lt;varname&gt;</code> will be simple text in Stata (e.g.,
<code>avg_income</code>) while in Python it will be a string (<code>'avg_income'</code>).
If you were to write <code>df[avg_income]</code> without quotes, Python would go
looking for a variable--a list, a number, a string--that's been defined
somewhere else. Because of this, <code>&lt;varlist&gt;</code> in Python represents a list
of variable names: <code>['educ', 'income', 2017]</code>.</p>
</div>
<div class="section" id="note-on-composability">
<h2><a class="toc-backref" href="#id2">2&nbsp;&nbsp;&nbsp;Note on composability</a></h2>
<p>One concept that will push your Python skills forward quickly is
&quot;composability.&quot; That is, you can combine base-level commands to &quot;create&quot; whole
new commands. This is a little more difficult in Stata where each line of code
acts on an entire dataset.</p>
<p>For example, let's say you know two commands in Python/pandas. First,
<code>df[&lt;condition&gt;]</code>, which returns the rows of DataFrame <code>df</code> for
which the Boolean <code>&lt;condition&gt;</code> is True. This is like <code>keep if
&lt;condition&gt;</code> in Stata, except <code>df[&lt;condition&gt;]</code> is itself a DataFrame
that can be acted upon independently of <code>df</code> itself. <em>This means that you
now know the general</em> <code>if &lt;condition&gt;</code> <em>syntax for every other pandas
command.</em></p>
<p>So let's say the second command you know is <code>df.describe()</code> which is the
equivalent of Stata's <code>summary</code>. This command doesn't have it's own
dedicated <code>if</code> command. It doesn't need one. All you need is
<code>df[&lt;condition&gt;].describe()</code>.</p>
<p>In this way, you can create (i.e., &quot;compose&quot;) new commands. You may notice that
sometimes Python/pandas will require composed commands where Stata uses a
one-liner (for example, see Stata's <code>drop varstem*</code> below). While it may
may annoying to type a few more characters, this is actually a good thing! It
means that there are fewer base commands to learn in pandas. It's like learning
an alphabet with 26 letters and composing millions of words instead of learning
millions of individual hieroglyphs.</p>
<p>This also means that sometimes there is more than one way to do things.
Sometimes, it doesn't matter which way you do it. Other times, one way of doing
things will execute more quickly. You can use the <code>%timeit</code> magic command
in IPython to easily test which one is faster. But this will usually only an
issue with with larger data sets (usually several gigabytes). For example,
in large Groupby operations <code>.shift(fillna=0)</code> is much, much slower than
<code>shift().fillna(0)</code> even though the end result is the same.</p>
</div>
<div class="section" id="input-output">
<h2><a class="toc-backref" href="#id3">3&nbsp;&nbsp;&nbsp;Input/Output</a></h2>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stata</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>log using &lt;file&gt;</code></td>
<td>Python doesn't display results automatically like Stata. You have to
explicitly call the <code>print</code> function. Using a Jupyter notebook is
the closest equivalent.</td>
</tr>
<tr><td><code>help &lt;command&gt;</code></td>
<td><ol class="first last arabic simple">
<li><code>help(&lt;command&gt;)</code> OR</li>
<li><code>&lt;command&gt;?</code> in IPython (as in <code>pd.read_stata?</code>)</li>
</ol>
</td>
</tr>
<tr><td><code>cd some/other/directory</code></td>
<td><div class="first last line-block">
<div class="line"><code>import os</code></div>
<div class="line"><code>os.chdir('some/other/directory')</code></div>
<div class="line">but this is bad practice. Better practice is to use full pathnames whenever possible.</div>
</div>
</td>
</tr>
<tr><td><code>use my_file</code></td>
<td><div class="first last line-block">
<div class="line"><code>import pandas as pd</code></div>
<div class="line"><code>df = pd.read_stata('my_file.dta')</code></div>
</div>
</td>
</tr>
<tr><td><code>use var1 var2 using my_file</code></td>
<td><code>df = pd.read_stata('my_file.dta', columns=['var1', 'var2'])</code></td>
</tr>
<tr><td><code>import excel using &lt;excelfile&gt;</code></td>
<td><code>df = pd.read_excel('&lt;excelfile&gt;')</code></td>
</tr>
<tr><td><code>import delimited using my_file.csv</code></td>
<td><code>df = pd.read_csv('my_file.csv')</code></td>
</tr>
<tr><td><code>save my_file, replace</code></td>
<td><ol class="first last arabic simple">
<li><code>df.to_stata('my_file.dta')</code> OR</li>
<li><code>df.to_pickle('my_file.pkl')</code> for Python-native file type.</li>
</ol>
</td>
</tr>
<tr><td><code>outsheet using my_file.csv, comma</code></td>
<td><code>df.to_csv('my_file.csv')</code></td>
</tr>
<tr><td><code>export excel using &lt;excel_name&gt;</code></td>
<td><code>df.to_excel('&lt;excel_name&gt;')</code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sample-selection">
<h2><a class="toc-backref" href="#id4">4&nbsp;&nbsp;&nbsp;Sample Selection</a></h2>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stata</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>keep if &lt;condition&gt;</code></td>
<td><code>df = df[&lt;condition&gt;]</code></td>
</tr>
<tr><td><code>keep if a &gt; 7</code></td>
<td><code>df = df[df['a'] &gt; 7]</code></td>
</tr>
<tr><td><code>drop if &lt;condition&gt;</code></td>
<td><code>df = df[~(&lt;condition&gt;)]</code> where <code>~</code> is the logical negation
operator in pandas and numpy (and bitwise negation for Python more
generally).</td>
</tr>
<tr><td><code>keep if _n == 1</code></td>
<td><ol class="first last arabic simple">
<li><code>df.first()</code> OR</li>
<li><code>df.iloc[0, :]</code> Python is a 0-indexed language, so when counting the elements of lists and arrays, you start with 0 instead of 1.</li>
</ol>
</td>
</tr>
<tr><td><code>keep if _n == _N</code></td>
<td><ol class="first last arabic simple">
<li><code>df = df.last()</code> OR</li>
<li><code>df = df.iloc[-1, :]</code></li>
</ol>
</td>
</tr>
<tr><td><code>keep if _n == 7</code></td>
<td><code>df = df.iloc[6, :]</code> (Remember to count from 0)</td>
</tr>
<tr><td><code>keep if _n &lt;= 10</code></td>
<td><code>df = df.iloc[:9, :]</code> (Remember to count from 0)</td>
</tr>
<tr><td><code>keep var</code></td>
<td><code>df = df['var']</code></td>
</tr>
<tr><td><code>keep var1 var2</code></td>
<td><code>df = df[['var1', 'var2']]</code></td>
</tr>
<tr><td><code>keep varstem*</code></td>
<td><code>df = df.filter(like='varstem')</code></td>
</tr>
<tr><td><code>drop var</code></td>
<td><ol class="first last arabic simple">
<li><code>del df['var']</code> OR</li>
<li><code>df = df.drop('var', axis=1)</code></li>
</ol>
</td>
</tr>
<tr><td><code>drop var1 var2</code></td>
<td><code>df = df.drop(['var1', 'var2'], axis=1)</code></td>
</tr>
<tr><td><code>drop varstem*</code></td>
<td><code>df = df.drop(df.filter(like='varstem*').columns, axis=1)</code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="data-info-and-summary-statistics">
<h2><a class="toc-backref" href="#id5">5&nbsp;&nbsp;&nbsp;Data Info and Summary Statistics</a></h2>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stata</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>describe</code></td>
<td><code>df.info()</code> OR <code>df.dtypes</code> just to get data types. Note that
Python does not have value labels like Stata does.</td>
</tr>
<tr><td><code>describe var</code></td>
<td><code>df['var'].dtype</code></td>
</tr>
<tr><td><code>count</code></td>
<td><ol class="first last arabic simple">
<li><code>df.shape[0]</code> OR</li>
<li><code>len(df)</code>. Here <code>df.shape</code> returns a tuple with the length and width of the DataFrame.</li>
</ol>
</td>
</tr>
<tr><td><code>count if &lt;condition&gt;</code></td>
<td><ol class="first last arabic simple">
<li><code>df[&lt;condition&gt;].shape[0]</code> OR</li>
<li><code>(&lt;condition&gt;).sum()</code> if the condition involves a DataFrame, e.g., <code>(df['age'] &gt; 2).sum()</code></li>
</ol>
</td>
</tr>
<tr><td><code>summ var</code></td>
<td><code>df['var'].describe()</code></td>
</tr>
<tr><td><code>summ var if &lt;condition&gt;</code></td>
<td><ol class="first last arabic simple">
<li><code>df[&lt;condition&gt;]['var'].describe()</code> OR</li>
<li><code>df.loc[&lt;condition&gt;, 'var'].describe()</code></li>
</ol>
</td>
</tr>
<tr><td><code>summ var [aw = &lt;weight&gt;]</code></td>
<td>Right now you have to calculate weighted summary stats manually. There
are also some tools available in the Statsmodels package.</td>
</tr>
<tr><td><code>summ var, d</code></td>
<td><code>df['var'].describe()</code> plus <code>df['var'].quantile([.1, .25,
.5, .75, .9])</code> or whatever other statistics you want.</td>
</tr>
<tr><td><code>tab var</code></td>
<td><code>df['var'].value_counts()</code></td>
</tr>
<tr><td><code>tab var1 var2</code></td>
<td><ol class="first last arabic">
<li><p class="first"><code>pd.crosstab(df['var1'], df['var2'])</code></p>
</li>
<li><div class="first"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;var1&#39;</span><span class="p">,</span> <span class="s1">&#39;var2&#39;</span><span class="p">])</span>
  <span class="o">.</span><span class="n">size</span><span class="p">()</span>
  <span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="s1">&#39;var2&#39;</span><span class="p">)</span>
</pre></div>
</div><p>Note that the <code>.unstack(&lt;var2&gt;)</code> here is purely cosmetic: it
transforms the data from &quot;long&quot; to &quot;wide&quot; which is how crosstabs
are usually presented.</p>
</li>
</ol>
</td>
</tr>
<tr><td><code>tab &lt;var1&gt; &lt;var2&gt;, summarize(&lt;func&gt;)</code></td>
<td><div class="first last"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;var1&#39;</span><span class="p">,</span> <span class="s1">&#39;var2&#39;</span><span class="p">])</span>
  <span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="o">&lt;</span><span class="n">func</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="s1">&#39;var2&#39;</span><span class="p">)</span>
</pre></div>
</div></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="variable-manipulation">
<h2><a class="toc-backref" href="#id6">6&nbsp;&nbsp;&nbsp;Variable Manipulation</a></h2>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stata</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>gen newvar = &lt;expression&gt;</code></td>
<td><code>df['newvar'] = &lt;expression&gt;</code></td>
</tr>
<tr><td><code>gen newvar = oldvar + 7</code></td>
<td><code>df['newvar'] = df['oldvar'] + 7</code></td>
</tr>
<tr><td><code>gen newvar = &lt;expression&gt; if &lt;condition&gt;</code></td>
<td><code>df.loc[&lt;condition&gt;, 'newvar'] = &lt;expression&gt;</code>.  As with Stata,
the rows of <code>df</code> that don't meet the condition will be missing
(<code>numpy.nan</code>).</td>
</tr>
<tr><td><code>replace var = &lt;expression&gt; if &lt;condition&gt;</code></td>
<td><code>df.loc[&lt;condition&gt;, 'var'] = &lt;expression&gt;</code></td>
</tr>
<tr><td><code>rename var newvar</code></td>
<td><code>df = df.rename(columns={'var': 'newvar'})</code>. You can also directly
manipulate <code>df.columns</code> like a list: <code>df.columns = ['a',
'b', 'c']</code>.</td>
</tr>
<tr><td><code>inlist(var, &lt;val1&gt;, &lt;val2&gt;)</code></td>
<td><code>df['var'].isin((&lt;val1&gt;, &lt;val2&gt;))</code></td>
</tr>
<tr><td><code>inrange(var, &lt;val1&gt;, &lt;val2&gt;)</code></td>
<td><code>df['var'].between((&lt;val1&gt;, &lt;val2&gt;))</code></td>
</tr>
<tr><td><code>subinstr(&lt;str&gt;, &quot;  &quot;, &quot;_&quot;, .)</code></td>
<td><code>df['var'].str.replace(' ', '_')</code></td>
</tr>
<tr><td><code>egen newvar = count(var)</code></td>
<td><code>newvar = df['var'].notnull().sum()</code>. NOTE: For these
<code>egen</code> commands, <code>newvar</code> is a full (constant) column in Stata, while it is a scalar in Python. If you want a full constant column on your DataFrame, you can do <code>df['newvar'] = 7</code> or whatever the constant is.</td>
</tr>
<tr><td><code>egen &lt;newvar&gt; = max(var)</code></td>
<td><code>&lt;newvar&gt; = df['var'].max()</code></td>
</tr>
<tr><td><code>egen &lt;newvar&gt; = mean(var)</code></td>
<td><code>&lt;newvar&gt; = df['var'].mean()</code></td>
</tr>
<tr><td><code>egen &lt;newvar&gt; = total(var)</code></td>
<td><code>&lt;newvar&gt; = df['var'].sum()</code></td>
</tr>
<tr><td><code>egen &lt;newvar&gt; = group(var1 var2)</code></td>
<td><code>&lt;newvar&gt; = econtools.group_id(df, cols=['var1', 'var2])</code> Please see the documentation for <code>group_id</code>.</td>
</tr>
<tr><td><code>egen newvar = &lt;stat&gt;(var), by(groupvar1 groupvar2)</code></td>
<td><code>df['newvar']  = df.groupby(['groupvar1', 'groupvar2'])['var'].transform('&lt;stat&gt;')</code>.</td>
</tr>
<tr><td><div class="first last line-block">
<div class="line"><code>collapse (sd) var (median) var ///</code></div>
<div class="line-block">
<div class="line"><code>(max) var (min) var, ///</code></div>
<div class="line"><code>by(groupvar1 groupvar2)</code></div>
</div>
</div>
</td>
<td><code>df.groupby(['groupvar1', 'groupvar2'])['var'].agg(['std', 'median', 'min', 'max', 'sum'])</code></td>
</tr>
<tr><td><code>collapse (&lt;stat&gt;) var [iw = &lt;weight&gt;]</code></td>
<td>Manually or maybe Statsmodels has a tool.</td>
</tr>
<tr><td><code>collapse (mean) var1, var2, by(groupvar1 groupvar2)</code></td>
<td><code>df.groupby(['groupvar1', 'groupvar2'])[['var1', 'var2']].mean()</code></td>
</tr>
<tr><td><code>recode var (1/5 = 1)</code></td>
<td>N/A, see note below.</td>
</tr>
<tr><td><code>recode var (1/5 = 1), gen(&lt;newvar&gt;)</code></td>
<td>N/A.</td>
</tr>
<tr><td><code>label var var &lt;label&gt;</code></td>
<td>N/A.</td>
</tr>
<tr><td><code>label define &lt;labelname&gt; 1 &lt;valuelabel&gt;</code></td>
<td>N/A.</td>
</tr>
<tr><td><code>label values var &lt;labelname&gt;</code></td>
<td>N/A.</td>
</tr>
<tr><td><code>label list &lt;labelname&gt;</code></td>
<td>N/A.</td>
</tr>
</tbody>
</table>
<p>Python doesn't have &quot;labels&quot; built into DataFrames like Stata does. However,
you can use a dictionary to map data values to labels when necessary.</p>
<div class="highlight"><pre><span></span><span class="n">variable_labels</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;First Category&quot;</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;Second Category&quot;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;Last Category&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="bysort">
<h2><a class="toc-backref" href="#id7">7&nbsp;&nbsp;&nbsp;Bysort</a></h2>
<p>All <code>bysort</code> and <code>egen</code> commands will be compositions using
<code>groupby.agg</code> or <code>groupby.transform</code></p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stata</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>bys group_var1 group_var2: gen group_sum = sum(var)</code></td>
<td><ol class="first last arabic simple">
<li><code>df['group_sum'] = df.groupby(['group_var1', 'group_var2'])['var'].transform('sum')</code></li>
<li><code>df['group_sum'] = df.groupby(['group_var1', 'group_var2'])['var'].transform(np.sum)</code> Note that <code>transform</code> can take a string name of common functions like sum, mean, etc., or an arbitrary function to be executed, including <code>np.sum</code> or a function of your own creation.</li>
</ol>
</td>
</tr>
<tr><td><code>bys group_var1 group_var2 (sort_var): keep if _n==1</code></td>
<td><ol class="first last arabic">
<li><div class="first"><div class="highlight"><pre><span></span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;group_sum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">df</span>
    <span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;group_var1&#39;</span><span class="p">,</span> <span class="s1">&#39;group_var2&#39;</span><span class="p">,</span> <span class="s1">&#39;sort_var1&#39;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">([</span><span class="s1">&#39;group_var1&#39;</span><span class="p">,</span> <span class="s1">&#39;group_var2&#39;</span><span class="p">],</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div></li>
<li><div class="first"><div class="highlight"><pre><span></span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;group_sum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">df</span>
    <span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;group_var1&#39;</span><span class="p">,</span> <span class="s1">&#39;group_var2&#39;</span><span class="p">,</span> <span class="s1">&#39;sort_var1&#39;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;var1&#39;</span><span class="p">,</span> <span class="s1">&#39;var2&#39;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>
</div></li>
</ol>
</td>
</tr>
<tr><td><code>bys group_var1 group_var2 (sort_var): keep if _n==j</code> where
<code>j</code> is some arbitrary number</td>
<td><div class="first last"><div class="highlight"><pre><span></span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;group_sum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">df</span>
    <span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;group_var1&#39;</span><span class="p">,</span> <span class="s1">&#39;group_var2&#39;</span><span class="p">,</span> <span class="s1">&#39;sort_var1&#39;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;var1&#39;</span><span class="p">,</span> <span class="s1">&#39;var2&#39;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
<span class="p">)</span>
</pre></div>
</div></td>
</tr>
<tr><td><code>bys group_var1 group_var2 (sort_var): gen jth_val = var[j]</code> where
<code>j</code> is some arbitrary number</td>
<td><div class="first last"><div class="highlight"><pre><span></span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;jth_val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">df</span>
    <span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;group_var1&#39;</span><span class="p">,</span> <span class="s1">&#39;group_var2&#39;</span><span class="p">,</span> <span class="s1">&#39;sort_var1&#39;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;var1&#39;</span><span class="p">,</span> <span class="s1">&#39;var2&#39;</span><span class="p">])[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>
    <span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
<span class="p">)</span>
</pre></div>
</div></td>
</tr>
</tbody>
</table>
<p>Note that <code>groupby</code> was also used above to accomplish a <code>collapse</code>.
Like, a Stata Collapse, a pandas Groupby reduces the size of the data set. If
you want to instead execute what's called a window function in SQL, which does
not reduce the shape of the original data set, you can call
<code>df.groupby.transform(&lt;function&gt;)</code> instead of
<code>df.groupby.agg(&lt;function&gt;)</code>.</p>
<p>If for some reason <code>transform</code> doesn't work in your use case, you can
also re-join the collapsed data back onto your original data set:</p>
<div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;my_data.csv&#39;</span><span class="p">)</span>
<span class="n">state_pop_sum</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;state&#39;</span><span class="p">)[</span><span class="s1">&#39;population&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_pop_sum</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="s1">&#39;state_pop_sum&#39;</span><span class="p">),</span>     <span class="c1"># Give the new column a name besides &#39;population&#39;</span>
             <span class="n">on</span><span class="o">=</span><span class="s1">&#39;state&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="panel-data">
<h2><a class="toc-backref" href="#id8">8&nbsp;&nbsp;&nbsp;Panel Data</a></h2>
<p>There is no general equivalent to <code>tsset</code> in Python. However, you can
accomplish most if not all of the same tasks using a DataFrame's index (the
row's equivalent of columns.) In Stata, the &quot;DataFrame&quot; in memory always has
the observation row number, denoted by the Stata built-in variable <code>_n</code>.
In Python and Pandas, a DataFrame index can be anything (though you can also
refer to rows by the row number; see <code>.loc</code> vs <code>iloc</code>). It can also
be hierarchical with mutiple levels. It is a much more general tool than
<code>tsset</code>.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stata</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>tsset panelvar timevar</code></td>
<td><code>df = df.set_index(['panelvar', 'timevar'])</code></td>
</tr>
<tr><td><code>L.var</code></td>
<td><code>df['var'].shift()</code> NOTE: The index must be
correctly sorted for <code>shift</code> to work the way you want it to. You
will also probably need to use a <code>groupby</code>; see below.</td>
</tr>
<tr><td><code>L2.var</code></td>
<td><code>df['var'].shift(2)</code></td>
</tr>
<tr><td><code>F.var</code></td>
<td><code>df['var'].shift(-1)</code></td>
</tr>
</tbody>
</table>
<div class="section" id="examples">
<h3>8.1&nbsp;&nbsp;&nbsp;Examples</h3>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">df0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;var1&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
   <span class="o">...</span><span class="p">:</span>                     <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
   <span class="o">...</span><span class="p">:</span>                     <span class="s1">&#39;period&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">})</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="k">print</span><span class="p">(</span><span class="n">df0</span><span class="p">)</span>
   <span class="n">var1</span>  <span class="nb">id</span>  <span class="n">period</span>
<span class="mi">0</span>     <span class="mi">0</span>   <span class="mi">1</span>       <span class="mi">0</span>
<span class="mi">1</span>     <span class="mi">1</span>   <span class="mi">1</span>       <span class="mi">1</span>
<span class="mi">2</span>     <span class="mi">2</span>   <span class="mi">2</span>       <span class="mi">0</span>
<span class="mi">3</span>     <span class="mi">3</span>   <span class="mi">2</span>       <span class="mi">1</span>
<span class="mi">4</span>     <span class="mi">4</span>   <span class="mi">3</span>       <span class="mi">0</span>
<span class="mi">5</span>     <span class="mi">5</span>   <span class="mi">3</span>       <span class="mi">1</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="n">df</span> <span class="o">=</span> <span class="n">df0</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;period&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
           <span class="n">var1</span>
<span class="nb">id</span> <span class="n">period</span>
<span class="mi">1</span>  <span class="mi">0</span>          <span class="mi">0</span>
   <span class="mi">1</span>          <span class="mi">1</span>
<span class="mi">2</span>  <span class="mi">0</span>          <span class="mi">2</span>
   <span class="mi">1</span>          <span class="mi">3</span>
<span class="mi">3</span>  <span class="mi">0</span>          <span class="mi">4</span>
   <span class="mi">1</span>          <span class="mi">5</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">7</span><span class="p">]:</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;var1_lag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)[</span><span class="s1">&#39;var1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">()</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">8</span><span class="p">]:</span> <span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
           <span class="n">var1</span>  <span class="n">var1_lag</span>
<span class="nb">id</span> <span class="n">period</span>
<span class="mi">1</span>  <span class="mi">0</span>          <span class="mi">0</span>       <span class="n">NaN</span>
   <span class="mi">1</span>          <span class="mi">1</span>       <span class="mf">0.0</span>
<span class="mi">2</span>  <span class="mi">0</span>          <span class="mi">2</span>       <span class="n">NaN</span>
   <span class="mi">1</span>          <span class="mi">3</span>       <span class="mf">2.0</span>
<span class="mi">3</span>  <span class="mi">0</span>          <span class="mi">4</span>       <span class="n">NaN</span>
   <span class="mi">1</span>          <span class="mi">5</span>       <span class="mf">4.0</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">9</span><span class="p">]:</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;var1_for&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;id&#39;</span><span class="p">)[</span><span class="s1">&#39;var1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
           <span class="n">var1</span>  <span class="n">var1_lag</span>  <span class="n">var1_for</span>
<span class="nb">id</span> <span class="n">period</span>
<span class="mi">1</span>  <span class="mi">0</span>          <span class="mi">0</span>       <span class="n">NaN</span>       <span class="mf">1.0</span>
   <span class="mi">1</span>          <span class="mi">1</span>       <span class="mf">0.0</span>       <span class="n">NaN</span>
<span class="mi">2</span>  <span class="mi">0</span>          <span class="mi">2</span>       <span class="n">NaN</span>       <span class="mf">3.0</span>
   <span class="mi">1</span>          <span class="mi">3</span>       <span class="mf">2.0</span>       <span class="n">NaN</span>
<span class="mi">3</span>  <span class="mi">0</span>          <span class="mi">4</span>       <span class="n">NaN</span>       <span class="mf">5.0</span>
   <span class="mi">1</span>          <span class="mi">5</span>       <span class="mf">4.0</span>       <span class="n">NaN</span>
</pre></div>
</div>
</div>
<div class="section" id="merging-and-joining">
<h2><a class="toc-backref" href="#id9">9&nbsp;&nbsp;&nbsp;Merging and Joining</a></h2>
<p>NOTE: Merging in Python is like R, SQL, etc. See additional explanation below.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stata</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>append using &lt;filename&gt;</code></td>
<td><code>df_joint = df1.append(df2)</code></td>
</tr>
<tr><td><code>merge 1:1 &lt;vars&gt; using &lt;filename&gt;</code></td>
<td><ol class="first last arabic simple">
<li><code>df_joint = df1.join(df2)</code> if <code>&lt;vars&gt;</code> are the DataFrames' indexes, or</li>
<li><code>df_joint = pd.merge(df1, df2, on=&lt;vars&gt;)</code> otherwise. Beware that <code>pd.merge</code> will not keep the index of either DataFrame.</li>
</ol>
</td>
</tr>
</tbody>
</table>
<p>Merging with Pandas DataFrames does not require you to specify &quot;many-to-one&quot; or
&quot;one-to-many&quot;. Pandas will figure that out based on whether the variables
you're merging on are unique or not. However, you can specify what sub-sample
of the merge to keep using the keyword argument <code>how</code>, e.g.,
<code>df_joint = df1.join(df2, how='left')</code> is the default for <code>join</code>
while <code>how='inner'</code> is the default for <code>pd.merge</code>.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="27%" />
<col width="27%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Pandas <code>how</code></th>
<th class="head">Stata <code>, keep()</code></th>
<th class="head">Intuition</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>how='left'</code></td>
<td><code>keep(1, 3)</code></td>
<td>Keeps all observations in the &quot;left&quot; DataFrame.</td>
</tr>
<tr><td><code>how='right'</code></td>
<td><code>keep(2, 3)</code></td>
<td>Keeps all observations in the &quot;right&quot; DataFrame.</td>
</tr>
<tr><td><code>how='inner'</code></td>
<td><code>keep(3)</code></td>
<td>Keeps observations that are in both DataFrames.</td>
</tr>
<tr><td><code>how='outer'</code></td>
<td><code>keep(1 2 3)</code></td>
<td>Keeps all observations.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="reshape">
<h2><a class="toc-backref" href="#id10">10&nbsp;&nbsp;&nbsp;Reshape</a></h2>
<p>Like with merging, reshaping a DataFrame in Python is a bit different because
of the paradigm shift from the &quot;only one data table in memory&quot; model of Stata
to &quot;a data table is just another object/variable&quot; of Python. But this
difference also makes reshaping a little easier in Python.</p>
<p>The most fundamental reshape commands in Python/pandas are <code>stack</code> and
<code>unstack</code>:</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="nb">long</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
   <span class="o">...</span><span class="p">:</span>                     <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;some_variable&#39;</span><span class="p">],</span>
   <span class="o">...</span><span class="p">:</span>                     <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span>
   <span class="o">...</span><span class="p">:</span>                         <span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
   <span class="o">...</span><span class="p">:</span>                          <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
   <span class="o">...</span><span class="p">:</span>                          <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
   <span class="o">...</span><span class="p">:</span>                          <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]))</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="nb">long</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;unit_id&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="nb">long</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;varname&#39;</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="nb">long</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span>
<span class="n">varname</span>       <span class="n">some_variable</span>
<span class="n">unit_id</span> <span class="n">time</span>
<span class="n">a</span>       <span class="mi">1</span>                 <span class="mi">0</span>
        <span class="mi">2</span>                 <span class="mi">1</span>
<span class="n">b</span>       <span class="mi">1</span>                 <span class="mi">2</span>
        <span class="mi">2</span>                 <span class="mi">3</span>
<span class="n">c</span>       <span class="mi">1</span>                 <span class="mi">4</span>
        <span class="mi">2</span>                 <span class="mi">5</span>
<span class="n">d</span>       <span class="mi">1</span>                 <span class="mi">6</span>
        <span class="mi">2</span>                 <span class="mi">7</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">7</span><span class="p">]:</span> <span class="n">wide</span> <span class="o">=</span> <span class="nb">long</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">8</span><span class="p">]:</span> <span class="n">wide</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">8</span><span class="p">]:</span>
<span class="n">varname</span> <span class="n">some_variable</span>
<span class="n">time</span>                <span class="mi">1</span>  <span class="mi">2</span>
<span class="n">unit_id</span>
<span class="n">a</span>                   <span class="mi">0</span>  <span class="mi">1</span>
<span class="n">b</span>                   <span class="mi">2</span>  <span class="mi">3</span>
<span class="n">c</span>                   <span class="mi">4</span>  <span class="mi">5</span>
<span class="n">d</span>                   <span class="mi">6</span>  <span class="mi">7</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">9</span><span class="p">]:</span> <span class="n">long2</span> <span class="o">=</span> <span class="n">wide</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="n">long2</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">10</span><span class="p">]:</span>
<span class="n">varname</span>       <span class="n">some_variable</span>
<span class="n">unit_id</span> <span class="n">time</span>
<span class="n">a</span>       <span class="mi">1</span>                 <span class="mi">0</span>
        <span class="mi">2</span>                 <span class="mi">1</span>
<span class="n">b</span>       <span class="mi">1</span>                 <span class="mi">2</span>
        <span class="mi">2</span>                 <span class="mi">3</span>
<span class="n">c</span>       <span class="mi">1</span>                 <span class="mi">4</span>
        <span class="mi">2</span>                 <span class="mi">5</span>
<span class="n">d</span>       <span class="mi">1</span>                 <span class="mi">6</span>
        <span class="mi">2</span>                 <span class="mi">7</span>
</pre></div>
<p>Here Input 3 creates a DataFrame, Input 4 gives each of the index columns a
name, and Input 5 names the columns. Coming from Stata, it's a little weird to
think of the column names themselves having a &quot;name&quot;, but the columns names are
just an index like the row names are. It starts to make more sense when you
realize columns don't have to be strings. They can be integers, like years or
FIPS codes. In those cases, it makes a lot of sense to give the columns a name
so you know what you're dealing with.</p>
<p>Input 6 does the reshaping using <code>unstack('time')</code>, which takes the index
<code>'time'</code> and creates a new column for every unique value it has. Notice
that the columns now have multiple levels, just like the index previously did.
This is another good reason to label your index and columns. If you want to
access either of those columns, you can do so as usual, using a tuple to
differentiate between the two levels:</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">11</span><span class="p">]:</span> <span class="n">wide</span><span class="p">[(</span><span class="s1">&#39;some_variable&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">11</span><span class="p">]:</span>
<span class="n">unit_id</span>
<span class="n">a</span>    <span class="mi">0</span>
<span class="n">b</span>    <span class="mi">2</span>
<span class="n">c</span>    <span class="mi">4</span>
<span class="n">d</span>    <span class="mi">6</span>
<span class="n">Name</span><span class="p">:</span> <span class="p">(</span><span class="n">some_variable</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">int32</span>
</pre></div>
<p>If you want to combine the two levels (like Stata defaults to), you can simply
rename the columns:</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">13</span><span class="p">]:</span> <span class="n">wide_single_level_column</span> <span class="o">=</span> <span class="n">wide</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">14</span><span class="p">]:</span> <span class="n">wide_single_level_column</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">...</span><span class="p">:</span>        <span class="s1">&#39;{}_{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">wide_single_level_column</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">15</span><span class="p">]:</span> <span class="n">wide_single_level_column</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">15</span><span class="p">]:</span>
                  <span class="n">some_variable_1</span>  <span class="n">some_variable_2</span>
         <span class="n">unit_id</span>
         <span class="n">a</span>                      <span class="mi">0</span>                <span class="mi">1</span>
         <span class="n">b</span>                      <span class="mi">2</span>                <span class="mi">3</span>
         <span class="n">c</span>                      <span class="mi">4</span>                <span class="mi">5</span>
         <span class="n">d</span>                      <span class="mi">6</span>                <span class="mi">7</span>
</pre></div>
<p>The <code>pivot</code> command can also be useful, but it's a bit more complicated than <code>stack</code> and
<code>unstack</code> and is better to revisit <code>pivot</code> after you are
comfortable working with DataFrame indexes and columns.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stata</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>reshape &lt;wide/long&gt; &lt;stubs&gt;, i(&lt;i_vars&gt;) j(&lt;j_var&gt;)</code></td>
<td><div class="first last line-block">
<div class="line">wide: <code>df.unstack(&lt;level&gt;)</code></div>
<div class="line">long: <code>df.stack('j_var')</code></div>
<div class="line">see also <code>df.pivot</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="econometrics">
<h2><a class="toc-backref" href="#id11">11&nbsp;&nbsp;&nbsp;Econometrics</a></h2>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stata</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>ttest var1, by(var2)</code></td>
<td><div class="first last line-block">
<div class="line"><code>from scipy.stats import ttest_ind</code></div>
<div class="line"><code>ttest_ind(array1, array2)</code></div>
</div>
</td>
</tr>
<tr><td><code>xi: i.var</code></td>
<td><code>pd.get_dummies(df['var'])</code></td>
</tr>
<tr><td><code>i.var2#c.var1</code></td>
<td><code>pd.get_dummies(df[var2]).multiply(df[var1])</code></td>
</tr>
<tr><td><code>reg yvar xvar if &lt;condition&gt;, r</code></td>
<td><div class="first last line-block">
<div class="line"><code>import econtools.metrics as mt</code></div>
<div class="line"><code>results = mt.reg(df[&lt;condition&gt;], 'yvar', 'xvar', robust=True)</code></div>
</div>
</td>
</tr>
<tr><td><code>reg yvar xvar if &lt;condition&gt;,  vce(cluster cluster_var)</code></td>
<td><code>results = mt.reg(df[&lt;condition&gt;], 'yvar', 'xvar', cluster='cluster_var')</code></td>
</tr>
<tr><td><code>areg yvar xvar1 xvar2, absorb(fe_var)</code></td>
<td><code>results = mt.reg(df, 'yvar', ['xvar1', 'xvar2'], fe_name='fe_var')</code></td>
</tr>
<tr><td><code>predict newvar, resid</code></td>
<td><code>newvar = results.resid</code></td>
</tr>
<tr><td><code>predict newvar, xb</code></td>
<td><code>newvar = results.yhat</code></td>
</tr>
<tr><td><code>_b[var]</code>, <code>_se[var]</code></td>
<td><code>results.beta['var']</code>, <code>results.se['var']</code></td>
</tr>
<tr><td><code>test var1 var2</code></td>
<td><code>results.Ftest(['var1', 'var2'])</code></td>
</tr>
<tr><td><code>test var1 var2, equal</code></td>
<td><code>results.Ftest(['var1', 'var2'], equal=True)</code></td>
</tr>
<tr><td><code>lincom var1 + var2</code></td>
<td><code>econtools.metrics.f_test</code> with appropriate parameters.</td>
</tr>
<tr><td><code>ivreg2</code></td>
<td><code>econtools.metrics.ivreg</code></td>
</tr>
<tr><td><code>outreg2</code></td>
<td><code>econtools.outreg</code></td>
</tr>
<tr><td><code>reghdfe</code></td>
<td>None (hoping to add it to Econtools soon).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="plotting">
<h2><a class="toc-backref" href="#id12">12&nbsp;&nbsp;&nbsp;Plotting</a></h2>
<p>Visualizations are best handled by the packages Matplotlib and Seaborn.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stata</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>binscatter</code></td>
<td><code>econtools.binscatter</code></td>
</tr>
<tr><td><code>maptile</code></td>
<td>No quick tool, but easy to do with Cartopy.</td>
</tr>
<tr><td><code>coefplot</code></td>
<td><code>ax.scatter(results.beta.index, results.beta)</code> often works. Depends on context.</td>
</tr>
<tr><td><code>twoway scatter y_var x_var</code></td>
<td><code>df.scatter('x_var', 'y_var')</code></td>
</tr>
<tr><td><code>twoway scatter y_var x_var if &lt;condition&gt;</code></td>
<td><code>df[&lt;condition&gt;].scatter(x_var, y_var)</code></td>
</tr>
<tr><td><code>twoway &lt;connected/line/area/bar/rarea&gt;</code></td>
<td>As above with appropriate parameters passed to <code>df.plot</code> function.
However, it is better to use <code>matplotlib</code> or <code>seaborn</code>
directly and call <code>ax.plot(df['var1'], df['var2'])</code>. Like with
<code>merge</code>, it's a different paradigm that needs more explanation.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="other-differences">
<h2><a class="toc-backref" href="#id13">13&nbsp;&nbsp;&nbsp;Other differences</a></h2>
<div class="section" id="missing-values">
<h3>13.1&nbsp;&nbsp;&nbsp;Missing values</h3>
<p>In Python, missing values are represented by a NumPy &quot;not a number&quot; object,
<code>np.nan</code>. In Stata, missing (<code>.</code>) is larger than every number, so
<code>10 &lt; .</code> yields True. In Python, <code>np.nan</code> is never equal to
anything. Any comparison involving <code>np.nan</code> is always False, even
<code>np.nan == np.nan</code>.</p>
<p>To look for missing values in DataFrame columns, use any of the following.</p>
<ul class="simple">
<li><code>df[&lt;varname&gt;].isnull()</code> returns a vector of True and False values for each
row of <code>df[&lt;varname&gt;</code>.</li>
<li><code>df[&lt;varname&gt;].notnull()</code> is the complement of <code>.isnull()</code>.</li>
<li>The function <code>np.isnan(&lt;arraylike&gt;)</code> takes an array and returns True or
False for each element of the array (a DataFrame is a special type of array).</li>
</ul>
<p>Another important difference is that <code>np.nan</code> is a floating point data
type, so any column of a DataFrame that contains missing numbers will be
floats. If a column of integers gets changed so that even one element is
<code>np.nan</code>, the whole column will be converted to floats.</p>
</div>
<div class="section" id="floating-point-equality">
<h3>13.2&nbsp;&nbsp;&nbsp;Floating point equality</h3>
<p>In Stata, decimal numbers are never equal to anything, e.g., <code>3.0 == 3</code> is
False. In Python, the above equality check returns True as long as the floating
point error is within tolerances. However, you should be wary when
doing large-scale equality checks using floats, like when merging two data sets
using a variable/column that is a float. This is true for any language!  (Read
up on floating point error if you're curious why measuring equality of floats
is tricky.)</p>
</div>
</div>

        </div>
    </section>
        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>
<div id="aboutme">
        <p>
            <img width="100%" class="img-thumbnail" src="http://www.danielmsullivan.com/images/dms_med.jpg"/>
        </p>
</div><!-- Sidebar -->
<section class="well well-sm">
  <ul class="list-group list-group-flush">

<!-- Sidebar/Social -->
<li class="list-group-item">
  <h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
  <ul class="list-group" id="social">
    <li class="list-group-item"><a href="http://github.com/dmsul"><i class="fa fa-github-square fa-lg"></i> Github</a></li>
    <li class="list-group-item"><a href="https://twitter.com/Dan_M_Sullivan"><i class="fa fa-twitter-square fa-lg"></i> Twitter</a></li>
    <li class="list-group-item"><a href="mailto:sullivan@rff.org"><i class="fa fa-envelope fa-lg"></i> Email</a></li>
  </ul>
</li>
<!-- End Sidebar/Social -->

<!-- Sidebar/Links -->
<li class="list-group-item">
  <h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
  <ul class="list-group" id="links">
    <li class="list-group-item">
      <a href="https://scholar.google.com/citations?user=naLX3CIAAAAJ" target="_blank">Google Scholar</a>
    </li>
    <li class="list-group-item">
      <a href="http://orcid.org/0000-0002-0380-7681" target="_blank">ORCID</a>
    </li>
    <li class="list-group-item">
      <a href="https://ideas.repec.org/f/psu490.html" target="_blank">RePEc</a>
    </li>
    <li class="list-group-item">
      <a href="http://www.rff.org/people/profile/daniel-m-sullivan" target="_blank">RFF page</a>
    </li>
  </ul>
</li>
<!-- End Sidebar/Links -->
  </ul>
</section>
<!-- End Sidebar -->            </aside>
        </div>
    </div>
</div>
<!-- End Content Container -->

<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy;  Daniel M. Sullivan
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://www.danielmsullivan.com/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://www.danielmsullivan.com/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://www.danielmsullivan.com/theme/js/respond.min.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-88761020-1']);
        _gaq.push(['_trackPageview']);

        (function () {
            var ga = document.createElement('script');
            ga.type = 'text/javascript';
            ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ga, s);
        })();
    </script>
    <!-- End Google Analytics Code -->


</body>
</html>